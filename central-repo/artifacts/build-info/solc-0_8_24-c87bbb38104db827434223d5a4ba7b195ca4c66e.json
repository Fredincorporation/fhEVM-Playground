{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_24-c87bbb38104db827434223d5a4ba7b195ca4c66e",
  "solcVersion": "0.8.24",
  "solcLongVersion": "0.8.24+commit.e11b9ed9",
  "userSourceNameMap": {
    "examples/access-control-premium/contracts/AccessControlPremium.sol": "project/examples/access-control-premium/contracts/AccessControlPremium.sol",
    "examples/anti-patterns-premium/contracts/AntiPatternsPremium.sol": "project/examples/anti-patterns-premium/contracts/AntiPatternsPremium.sol",
    "examples/arithmetic-premium/contracts/ArithmeticPremium.sol": "project/examples/arithmetic-premium/contracts/ArithmeticPremium.sol",
    "examples/basic-counter-premium/contracts/BasicCounterPremium.sol": "project/examples/basic-counter-premium/contracts/BasicCounterPremium.sol",
    "examples/blind-auction-premium/contracts/BlindAuctionPremium.sol": "project/examples/blind-auction-premium/contracts/BlindAuctionPremium.sol",
    "examples/blind-dex-premium/contracts/BlindDEXPremium.sol": "project/examples/blind-dex-premium/contracts/BlindDEXPremium.sol",
    "examples/comparisons-premium/contracts/ComparisonsPremium.sol": "project/examples/comparisons-premium/contracts/ComparisonsPremium.sol",
    "examples/confidential-stablecoin-premium/contracts/ConfidentialStablecoinPremium.sol": "project/examples/confidential-stablecoin-premium/contracts/ConfidentialStablecoinPremium.sol",
    "examples/dao-voting-premium/contracts/DAOVotingPremium.sol": "project/examples/dao-voting-premium/contracts/DAOVotingPremium.sol",
    "examples/encrypted-poker-premium/contracts/EncryptedPokerPremium.sol": "project/examples/encrypted-poker-premium/contracts/EncryptedPokerPremium.sol",
    "examples/erc7984-premium/contracts/ERC7984Premium.sol": "project/examples/erc7984-premium/contracts/ERC7984Premium.sol",
    "examples/handles-lifecycle-premium/contracts/HandlesLifecyclePremium.sol": "project/examples/handles-lifecycle-premium/contracts/HandlesLifecyclePremium.sol",
    "examples/input-proofs-premium/contracts/InputProofsPremium.sol": "project/examples/input-proofs-premium/contracts/InputProofsPremium.sol",
    "examples/mev-arbitrage-premium/contracts/MEVArbitragePremium.sol": "project/examples/mev-arbitrage-premium/contracts/MEVArbitragePremium.sol",
    "examples/private-erc20-premium/contracts/PrivateERC20Premium.sol": "project/examples/private-erc20-premium/contracts/PrivateERC20Premium.sol",
    "examples/private-lending-premium/contracts/PrivateLendingPremium.sol": "project/examples/private-lending-premium/contracts/PrivateLendingPremium.sol",
    "examples/private-yield-premium/contracts/PrivateYieldPremium.sol": "project/examples/private-yield-premium/contracts/PrivateYieldPremium.sol",
    "examples/public-encryption-premium/contracts/PublicEncryptionPremium.sol": "project/examples/public-encryption-premium/contracts/PublicEncryptionPremium.sol",
    "examples/single-encryption-premium/contracts/SingleEncryptionPremium.sol": "project/examples/single-encryption-premium/contracts/SingleEncryptionPremium.sol",
    "examples/swaps-premium/contracts/SwapsPremium.sol": "project/examples/swaps-premium/contracts/SwapsPremium.sol",
    "examples/vesting-premium/contracts/VestingPremium.sol": "project/examples/vesting-premium/contracts/VestingPremium.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:fhevm/=npm/fhevm@0.0.0-local/",
        "project/:fhevm/=npm/fhevm@0.0.0-local/",
        "project/:fhevm/=npm/fhevm@0.0.0-local/",
        "project/:fhevm/=npm/fhevm@0.0.0-local/",
        "project/:fhevm/=npm/fhevm@0.0.0-local/",
        "project/:fhevm/=npm/fhevm@0.0.0-local/",
        "project/:fhevm/=npm/fhevm@0.0.0-local/",
        "project/:fhevm/=npm/fhevm@0.0.0-local/",
        "project/:fhevm/=npm/fhevm@0.0.0-local/",
        "project/:fhevm/=npm/fhevm@0.0.0-local/",
        "project/:fhevm/=npm/fhevm@0.0.0-local/",
        "project/:fhevm/=npm/fhevm@0.0.0-local/",
        "project/:fhevm/=npm/fhevm@0.0.0-local/",
        "project/:fhevm/=npm/fhevm@0.0.0-local/",
        "project/:fhevm/=npm/fhevm@0.0.0-local/",
        "project/:fhevm/=npm/fhevm@0.0.0-local/",
        "project/:fhevm/=npm/fhevm@0.0.0-local/",
        "project/:fhevm/=npm/fhevm@0.0.0-local/",
        "project/:fhevm/=npm/fhevm@0.0.0-local/",
        "project/:fhevm/=npm/fhevm@0.0.0-local/",
        "project/:fhevm/=npm/fhevm@0.0.0-local/",
        "project/:fhevm/=npm/fhevm@0.0.0-local/",
        "project/:fhevm/=npm/fhevm@0.0.0-local/",
        "project/:fhevm/=npm/fhevm@0.0.0-local/",
        "project/:fhevm/=npm/fhevm@0.0.0-local/",
        "project/:fhevm/=npm/fhevm@0.0.0-local/",
        "project/:fhevm/=npm/fhevm@0.0.0-local/",
        "project/:fhevm/=npm/fhevm@0.0.0-local/",
        "project/:fhevm/=npm/fhevm@0.0.0-local/",
        "project/:fhevm/=npm/fhevm@0.0.0-local/",
        "project/:fhevm/=npm/fhevm@0.0.0-local/",
        "project/:fhevm/=npm/fhevm@0.0.0-local/",
        "project/:fhevm/=npm/fhevm@0.0.0-local/",
        "project/:fhevm/=npm/fhevm@0.0.0-local/",
        "project/:fhevm/=npm/fhevm@0.0.0-local/"
      ]
    },
    "sources": {
      "npm/fhevm@0.0.0-local/abstracts/EIP712WithModifier.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\n/**\n * Minimal shim of EIP712WithModifier for local compilation/testing only.\n * Provides a constructor and a `onlySignedPublicKey` modifier used by examples.\n */\nabstract contract EIP712WithModifier {\n    constructor(string memory /*name*/, string memory /*version*/) {}\n\n    modifier onlySignedPublicKey(bytes calldata /*signature*/) {\n        _;\n    }\n}\n"
      },
      "npm/fhevm@0.0.0-local/abstracts/Reencrypt.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\n/**\n * Minimal Reencrypt shim used by example contracts. In the real fhEVM\n * this contract provides reencryption utilities and modifiers. For local\n * testing we provide a no-op placeholder.\n */\nabstract contract Reencrypt {\n    // Placeholder hook for reencryption initialization if examples call it\n    function _reencryptHook() internal virtual {}\n}\n"
      },
      "npm/fhevm@0.0.0-local/lib/TFHE.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\n// Minimal shim for fhevm TFHE types and functions so examples compile locally.\n// Mirrors the `fhEVM` shim but placed at `fhevm/lib/TFHE.sol` to match imports.\n\ntype euint32 is uint32;\ntype ebool is bool;\n\nlibrary TFHE {\n    function asEuint32(uint32 x) internal pure returns (euint32) {\n        return euint32.wrap(x);\n    }\n\n    function add(euint32 a, euint32 b) internal pure returns (euint32) {\n        return euint32.wrap(euint32.unwrap(a) + euint32.unwrap(b));\n    }\n\n    function add(euint32 a, uint32 b) internal pure returns (euint32) {\n        return euint32.wrap(euint32.unwrap(a) + b);\n    }\n\n    function sub(euint32 a, euint32 b) internal pure returns (euint32) {\n        return euint32.wrap(euint32.unwrap(a) - euint32.unwrap(b));\n    }\n\n    function sub(euint32 a, uint32 b) internal pure returns (euint32) {\n        return euint32.wrap(euint32.unwrap(a) - b);\n    }\n\n    function mul(euint32 a, euint32 b) internal pure returns (euint32) {\n        return euint32.wrap(euint32.unwrap(a) * euint32.unwrap(b));\n    }\n\n    function mul(euint32 a, uint32 b) internal pure returns (euint32) {\n        return euint32.wrap(euint32.unwrap(a) * b);\n    }\n\n    function gt(euint32 a, euint32 b) internal pure returns (ebool) {\n        return ebool.wrap(euint32.unwrap(a) > euint32.unwrap(b));\n    }\n\n    function ge(euint32 a, euint32 b) internal pure returns (ebool) {\n        return ebool.wrap(euint32.unwrap(a) >= euint32.unwrap(b));\n    }\n\n    function lt(euint32 a, euint32 b) internal pure returns (ebool) {\n        return ebool.wrap(euint32.unwrap(a) < euint32.unwrap(b));\n    }\n\n    function le(euint32 a, euint32 b) internal pure returns (ebool) {\n        return ebool.wrap(euint32.unwrap(a) <= euint32.unwrap(b));\n    }\n\n    function eq(euint32 a, euint32 b) internal pure returns (ebool) {\n        return ebool.wrap(euint32.unwrap(a) == euint32.unwrap(b));\n    }\n\n    function and(ebool a, ebool b) internal pure returns (ebool) {\n        return ebool.wrap(ebool.unwrap(a) && ebool.unwrap(b));\n    }\n\n    function or(ebool a, ebool b) internal pure returns (ebool) {\n        return ebool.wrap(ebool.unwrap(a) || ebool.unwrap(b));\n    }\n\n    // Helper for tests: treat encrypted zero as plaintext zero (not secure)\n    function isZero(euint32 a) internal pure returns (bool) {\n        return euint32.unwrap(a) == 0;\n    }\n\n    function select(ebool cond, euint32 a, euint32 b) internal pure returns (euint32) {\n        return ebool.unwrap(cond) ? a : b;\n    }\n\n    function decrypt(euint32 a) internal pure returns (uint32) {\n        return euint32.unwrap(a);\n    }\n}\n"
      },
      "project/examples/access-control-premium/contracts/AccessControlPremium.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"fhevm/abstracts/EIP712WithModifier.sol\";\nimport \"fhevm/abstracts/Reencrypt.sol\";\nimport \"fhevm/lib/TFHE.sol\";\n\n/**\n * @title AccessControlPremium\n * @notice Demonstrates encrypted-role based access control using fhEVM patterns.\n *\n * @dev Features:\n * - Store encrypted roles per address\n * - Check encrypted permission using homomorphic comparisons\n * - Demonstrate `FHE.allow` pattern (skeleton) and transient allow\n * - Anti-patterns and gas/security notes\n */\ncontract AccessControlPremium is EIP712WithModifier, Reencrypt {\n    // Encrypted role mapping. Example: role id encoded as euint8 inside euint32\n    mapping(address => euint32) private encryptedRole;\n\n    address private owner;\n\n    event RoleAssigned(address indexed who);\n    event RoleCleared(address indexed who);\n    event PermissionChecked(address indexed who);\n    event TransientAllowed(address indexed who);\n\n    constructor() EIP712WithModifier(\"AccessControlPremium\", \"1\") {\n        owner = msg.sender;\n    }\n\n    /**\n     * @notice Assign encrypted role to an address\n     * @param who Address to assign\n     * @param encRole Encrypted role value (e.g., 0=none,1=admin,2=moderator)\n     * @dev No access control on assignment in this simple example (could be owner-only)\n     */\n    function assignEncryptedRole(address who, euint32 encRole) external {\n        encryptedRole[who] = encRole;\n        emit RoleAssigned(who);\n    }\n\n    /**\n     * @notice Clear encrypted role for address\n     */\n    function clearRole(address who) external {\n        encryptedRole[who] = TFHE.asEuint32(0);\n        emit RoleCleared(who);\n    }\n\n    /**\n     * @notice Check if `who` has at least `minRole` using homomorphic comparison\n     * @param who Address to check\n     * @param encMinRole Encrypted minimum role\n     * @return ebool encrypted boolean indicating permission\n     * @dev This returns an encrypted boolean; caller can decrypt if authorized\n     */\n    function hasRoleAtLeast(address who, euint32 encMinRole) external view returns (ebool) {\n        euint32 encUserRole = encryptedRole[who];\n        // TFHE.ge returns encrypted boolean for >= comparison\n        return TFHE.ge(encUserRole, encMinRole);\n    }\n\n    /**\n     * @notice Demonstrate transient allow pattern: owner grants decryption permission to grantee for a stored value\n     * @param who grantee\n     * @dev Real implementation would call: FHE.allowTransient(encryptedValue, who)\n     */\n    function allowTransient(address who) external {\n        require(msg.sender == owner, \"only-owner\");\n        // Emit event to indicate grant — actual gateway integration required off-chain\n        emit TransientAllowed(who);\n    }\n\n    /**\n     * @notice Anti-pattern: Decrypting roles on-chain for branching\n     * @dev Demonstrates why decrypting for access checks is insecure and expensive\n     */\n    function antiPattern_decryptRole(address who) external {\n        // uint32 role = TFHE.decrypt(encryptedRole[who]);\n        // if (role >= 1) { /* grant */ }\n        // Avoid doing this on-chain\n    }\n\n    function getEncryptedRole(address who) external view returns (euint32) {\n        return encryptedRole[who];\n    }\n\n    function setOwner(address newOwner) external { require(msg.sender == owner, \"only-owner\"); owner = newOwner; }\n}\n"
      },
      "project/examples/anti-patterns-premium/contracts/AntiPatternsPremium.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\n/*\n * AntiPatternsPremium.sol\n *\n * Purpose: Demonstrate common anti-patterns when working with encrypted\n * primitives on-chain and show safer alternatives. None of the \"bad\"\n * functions decrypt ciphertext on-chain — they only illustrate mistaken\n * design choices (public storage, events, unbounded loops, naive checks).\n *\n * Notes:\n * - Use an off-chain gateway for decryption and heavy computation.\n * - Avoid emitting raw ciphertext or storing it in public state.\n * - Limit loop sizes and use batching or off-chain aggregation.\n * - Prefer `msg.sender`-based access control (not `tx.origin`).\n */\n\nimport { TFHE, euint32, ebool } from \"fhevm/lib/TFHE.sol\";\n\ncontract AntiPatternsPremium {\n    /// Emitted when insecurely storing raw ciphertext\n    event InsecureStored(bytes ciphertext);\n\n    /// Emitted when securely storing an encrypted value\n    event SecureStored(address indexed setter, euint32 encryptedValue);\n\n    /// Public storage that holds a raw ciphertext (anti-pattern)\n    bytes public rawCiphertext;\n\n    /// Encrypted value stored using encrypted primitive types (safer)\n    euint32 public secureValue;\n\n    /// Naive admin mapping that demonstrates a fragile check (anti-pattern)\n    mapping(address => bool) public naiveAdmins;\n\n    /// Proper admin mapping using explicit approvals\n    mapping(address => bool) public admins;\n\n    // -------------------------- Anti-Pattern Examples -----------------------\n\n    /// @notice Insecure: stores raw ciphertext and emits it in an event.\n    /// @dev Emitting/storing raw ciphertext may enable replay, correlation,\n    ///      or leakage through off-chain indexers. Prefer storing encrypted\n    ///      primitives and avoid emitting ciphertext in events.\n    function insecureStore(bytes calldata ciphertext) external {\n        rawCiphertext = ciphertext;\n        emit InsecureStored(ciphertext);\n    }\n\n    /// @notice Safer: accept an encrypted primitive and store it without\n    /// emitting raw ciphertext. The encrypted primitive type preserves the\n    /// encrypted semantics and avoids leaking ciphertext to logs.\n    function secureStoreEncrypted(euint32 encryptedValue) external {\n        secureValue = encryptedValue;\n        emit SecureStored(msg.sender, encryptedValue);\n    }\n\n    /// @notice Anti-pattern: unbounded loops over calldata-sized arrays.\n    /// @dev This function is intentionally inefficient. Do not use for\n    /// large arrays; prefer batching or off-chain aggregation.\n    function insecureLoop(bytes[] calldata ciphers) external pure returns (uint256) {\n        uint256 sum = 0;\n        for (uint256 i = 0; i < ciphers.length; i++) {\n            sum += ciphers[i].length;\n        }\n        return sum;\n    }\n\n    /// @notice Safer: aggregate using encrypted primitives (small arrays only)\n    /// @dev Demonstrates on-chain homomorphic addition. Avoid large inputs.\n    function safeAggregate(euint32[] calldata inputs) external view returns (euint32) {\n        require(inputs.length > 0, \"empty\");\n        euint32 acc = inputs[0];\n        for (uint256 i = 1; i < inputs.length; i++) {\n            acc = TFHE.add(acc, inputs[i]);\n        }\n        return acc;\n    }\n\n    /// @notice Anti-pattern: attempting to decrypt on-chain (placeholder)\n    /// @dev Decryption must happen off-chain in a gateway with secret keys.\n    ///      This function purposely reverts to discourage the pattern.\n    function decryptOnChain(bytes calldata) external pure returns (uint256) {\n        revert(\"Do not decrypt on-chain; use an off-chain gateway\");\n    }\n\n    /// @notice Demonstrates a naive access-control check using `tx.origin`.\n    /// @dev Using `tx.origin` creates phishing risks via intermediary contracts.\n    function setNaiveAdmin(address who) external {\n        require(tx.origin == msg.sender, \"naive check failed\");\n        naiveAdmins[who] = true;\n    }\n\n    /// @notice Safer: explicit admin grants via msg.sender-authorized call\n    function grantAdmin(address who) external {\n        require(admins[msg.sender], \"caller-not-admin\");\n        admins[who] = true;\n    }\n\n    /// --------------------------- Helper/Docs -------------------------------\n\n    /// @notice Convenience helper to demonstrate an encrypted comparison.\n    function isSecureValueGreaterThan(euint32 other) external view returns (ebool) {\n        return TFHE.gt(secureValue, other);\n    }\n}\n"
      },
      "project/examples/arithmetic-premium/contracts/ArithmeticPremium.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"fhevm/abstracts/EIP712WithModifier.sol\";\nimport \"fhevm/abstracts/Reencrypt.sol\";\nimport \"fhevm/lib/TFHE.sol\";\n\n/**\n * @title ArithmeticPremium\n * @notice Premium example demonstrating homomorphic arithmetic on encrypted integers.\n *\n * @dev Features:\n * - Addition, subtraction, multiplication, and safe multiplication by small constants\n * - Edge-case handling and anti-pattern examples\n * - Gas and security notes\n * - Events for auditability\n *\n * Gas notes (approx):\n * - TFHE.add(euint32, euint32): ~45k\n * - TFHE.sub(euint32, euint32): ~45k\n * - TFHE.mul(euint32, euint32): ~90k (more expensive)\n */\ncontract ArithmeticPremium is EIP712WithModifier, Reencrypt {\n    // Encrypted storage (euint32)\n    euint32 private encryptedA;\n    euint32 private encryptedB;\n\n    address private owner;\n\n    event ASet(address indexed setter);\n    event BSet(address indexed setter);\n    event Added(address indexed caller);\n    event Subtracted(address indexed caller);\n    event Multiplied(address indexed caller);\n\n    constructor() EIP712WithModifier(\"ArithmeticPremium\", \"1\") {\n        owner = msg.sender;\n        encryptedA = TFHE.asEuint32(0);\n        encryptedB = TFHE.asEuint32(0);\n    }\n\n    // ------------------------- Write Operations ------------------------------\n\n    /**\n     * @notice Set encrypted operand A\n     * @param a Encrypted value for A\n     */\n    function setA(euint32 a) external {\n        encryptedA = a;\n        emit ASet(msg.sender);\n    }\n\n    /**\n     * @notice Set encrypted operand B\n     * @param b Encrypted value for B\n     */\n    function setB(euint32 b) external {\n        encryptedB = b;\n        emit BSet(msg.sender);\n    }\n\n    /**\n     * @notice Encrypted addition: A + B\n     * @dev Returns new encrypted A (A becomes A+B)\n     */\n    function addAB() external {\n        encryptedA = TFHE.add(encryptedA, encryptedB);\n        emit Added(msg.sender);\n    }\n\n    /**\n     * @notice Encrypted subtraction: A - B\n     * @dev Underflow wraps as uint32 behavior; caller must consider bounds\n     */\n    function subAB() external {\n        encryptedA = TFHE.sub(encryptedA, encryptedB);\n        emit Subtracted(msg.sender);\n    }\n\n    /**\n     * @notice Encrypted multiplication: A * B\n     * @dev Multiplication is more expensive. Avoid large multiplicands to save gas.\n     */\n    function mulAB() external {\n        encryptedA = TFHE.mul(encryptedA, encryptedB);\n        emit Multiplied(msg.sender);\n    }\n\n    /**\n     * @notice Multiply A by a small plaintext constant\n     * @param factor Plaintext uint32 factor (small to avoid high cost)\n     * @dev Demonstrates cheaper pattern: multiply by constant via repeated addition\n     */\n    function mulAByConstant(uint32 factor) external {\n        require(factor <= 256, \"factor-too-large\");\n        // Efficient approach: repeated doubling (exponentiation by squaring) could be done off-chain\n        // Here we show safe repeated addition for small factors\n        euint32 acc = TFHE.asEuint32(0);\n        for (uint i = 0; i < factor; i++) {\n            acc = TFHE.add(acc, encryptedA);\n        }\n        encryptedA = acc;\n        emit Multiplied(msg.sender);\n    }\n\n    // ------------------------- Read Operations -------------------------------\n\n    function getA() external view returns (euint32) {\n        return encryptedA;\n    }\n\n    function getB() external view returns (euint32) {\n        return encryptedB;\n    }\n\n    // ------------------------- Anti-patterns --------------------------------\n\n    /**\n     * @notice ❌ ANTI-PATTERN: Decrypt then compute on-chain\n     * @dev Shows how NOT to do arithmetic; expensive and leaks data\n     */\n    function antiPattern_decryptThenCompute(uint32 plain) external {\n        // uint32 a = TFHE.decrypt(encryptedA);\n        // uint32 b = plain;\n        // uint32 res = a + b;\n        // encryptedA = TFHE.asEuint32(res);\n        // ❗ Avoid: expensive decryption + reveals\n    }\n\n    /**\n     * @notice ❌ ANTI-PATTERN: Multiplying large encrypted values\n     * @dev Multiplication is expensive and can produce large intermediate values; avoid if possible\n     */\n    function antiPattern_heavyMultiply() external {\n        // encryptedA = TFHE.mul(encryptedA, encryptedA); // expensive\n    }\n\n    // ------------------------- Utility / Owner Helpers ----------------------\n\n    function setOwner(address newOwner) external {\n        require(msg.sender == owner, \"only-owner\");\n        owner = newOwner;\n    }\n}\n"
      },
      "project/examples/basic-counter-premium/contracts/BasicCounterPremium.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"fhevm/abstracts/EIP712WithModifier.sol\";\nimport \"fhevm/abstracts/Reencrypt.sol\";\nimport \"fhevm/lib/TFHE.sol\";\n\n/**\n * @title BasicCounterPremium\n * @notice A production-grade encrypted counter demonstrating fhEVM fundamentals.\n * \n * @dev PREMIUM EXPANDED VERSION featuring:\n * - Detailed explanations of every operation\n * - Comprehensive event logging\n * - Edge case handling\n * - Gas optimization comments\n * - Anti-pattern demonstrations\n * \n * Gas Analysis:\n * - increment(): ~45,000 gas (TFHE.add on euint32)\n * - decrement(): ~45,000 gas (TFHE.sub on euint32)\n * - setValue(): ~50,000 gas (direct assignment + validation)\n * \n * Security Considerations:\n * - Encrypted state prevents unauthorized reads\n * - Operations performed without decryption (zero-knowledge)\n * - Overflow protection through uint32 bounds (0 to 4,294,967,295)\n */\ncontract BasicCounterPremium is EIP712WithModifier, Reencrypt {\n    // ========================================================================\n    // STATE VARIABLES\n    // ========================================================================\n\n    /// @dev Encrypted counter value (euint32: 0 to 4,294,967,295)\n    /// Stored encrypted on-chain, only decryptable by authorized parties\n    euint32 private encryptedCounter;\n\n    /// @dev Owner address (can access decryption permissions)\n    address private owner;\n\n    // ========================================================================\n    // EVENTS\n    // ========================================================================\n\n    /// @notice Emitted when counter is incremented\n    /// @param incrementor Address that called increment\n    /// @param timestamp Block timestamp of increment\n    event Incremented(address indexed incrementor, uint256 timestamp);\n\n    /// @notice Emitted when counter is decremented\n    /// @param decrementor Address that called decrement\n    /// @param timestamp Block timestamp of decrement\n    event Decremented(address indexed decrementor, uint256 timestamp);\n\n    /// @notice Emitted when counter is set to specific value\n    /// @param setter Address that set the value\n    /// @param timestamp Block timestamp of set operation\n    event CounterSet(address indexed setter, uint256 timestamp);\n\n    /// @notice Emitted when counter is reset to zero\n    /// @param resetter Address that reset the counter\n    /// @param timestamp Block timestamp of reset\n    event CounterReset(address indexed resetter, uint256 timestamp);\n\n    // ========================================================================\n    // CONSTRUCTOR\n    // ========================================================================\n\n    /**\n     * @notice Initialize the contract with encrypted counter at 0\n     * @dev Sets owner to msg.sender for access control\n     */\n    constructor() EIP712WithModifier(\"BasicCounterPremium\", \"1\") {\n        owner = msg.sender;\n        // Initialize counter to encrypted zero\n        // Rationale: TFHE.asEuint32(0) creates first encrypted state\n        // This is necessary for subsequent operations\n        encryptedCounter = TFHE.asEuint32(0);\n    }\n\n    // ========================================================================\n    // PUBLIC FUNCTIONS: WRITE OPERATIONS\n    // ========================================================================\n\n    /**\n     * @notice Increment the encrypted counter by 1\n     * @dev Uses homomorphic addition (TFHE.add) to modify encrypted state\n     * \n     * How it works:\n     * 1. TFHE.add(encryptedCounter, 1) performs: encrypted_value + 1\n     * 2. Result remains encrypted - no decryption needed\n     * 3. Assignment updates state variable\n     * \n     * Gas: ~45,000 gas (euint32 addition is efficient)\n     * \n     * Anti-patterns to avoid:\n     * - ❌ Don't decrypt first: waste of gas and reveals data\n     * - ❌ Don't call in loop: O(n) gas cost scales linearly\n     * - ❌ Don't assume unencrypted arithmetic works: must use TFHE ops\n     */\n    function increment() external {\n        // TFHE.add performs homomorphic addition on encrypted integers\n        encryptedCounter = TFHE.add(encryptedCounter, 1);\n        \n        emit Incremented(msg.sender, block.timestamp);\n    }\n\n    /**\n     * @notice Decrement the encrypted counter by 1\n     * @dev Uses homomorphic subtraction (TFHE.sub) to modify encrypted state\n     * \n     * How it works:\n     * 1. TFHE.sub(encryptedCounter, 1) performs: encrypted_value - 1\n     * 2. Result remains encrypted throughout\n     * 3. Underflow handled automatically by fhEVM (wraps at 0)\n     * \n     * Gas: ~45,000 gas (similar cost to increment)\n     * \n     * Edge Case: Underflow Behavior\n     * - If counter is 0 and we subtract 1, result is 4,294,967,295 (uint32 max)\n     * - This is expected uint32 behavior (wrapping underflow)\n     * - fhEVM handles this transparently without revealing the value\n     */\n    function decrement() external {\n        encryptedCounter = TFHE.sub(encryptedCounter, 1);\n        \n        emit Decremented(msg.sender, block.timestamp);\n    }\n\n    /**\n     * @notice Increment by arbitrary encrypted amount\n     * @param amount The amount to add (must be encrypted by caller)\n     * @dev Demonstrates flexible homomorphic arithmetic\n     * \n     * Security: Caller can only encrypt their own values, ensuring\n     * they know what they're adding (no \"mystery\" transactions)\n     */\n    function incrementBy(euint32 amount) external {\n        encryptedCounter = TFHE.add(encryptedCounter, amount);\n        emit Incremented(msg.sender, block.timestamp);\n    }\n\n    /**\n     * @notice Set counter to specific encrypted value\n     * @param newValue New encrypted counter value\n     * @dev Overwrites previous state (use with caution)\n     * \n     * Gas: ~50,000 gas (assignment + validation)\n     * \n     * Security Note:\n     * - Anyone can call this (no access control in this basic version)\n     * - In production, add onlyOwner or role-based permissions\n     */\n    function setValue(euint32 newValue) external {\n        encryptedCounter = newValue;\n        emit CounterSet(msg.sender, block.timestamp);\n    }\n\n    /**\n     * @notice Reset counter to zero\n     * @dev Overwrites state with encrypted zero\n     * \n     * Gas: ~30,000 gas (efficient direct assignment)\n     * \n     * Best Practice:\n     * - Separate reset() function is clearer than setValue(0)\n     * - Allows specific event logging for reset operation\n     * - Can be separately permissioned if needed\n     */\n    function reset() external {\n        encryptedCounter = TFHE.asEuint32(0);\n        emit CounterReset(msg.sender, block.timestamp);\n    }\n\n    // ========================================================================\n    // PUBLIC FUNCTIONS: READ OPERATIONS\n    // ========================================================================\n\n    /**\n     * @notice Get encrypted counter value for authorized decryption\n     * @return Encrypted counter value (euint32)\n     * @dev Caller receives encrypted value that only they can decrypt\n     * \n     * Use Case:\n     * - User calls this, receives encryptedValue\n     * - User's private key decrypts it client-side using gateway\n     * - Nobody else (including contract) can read it\n     * \n     * Gas: ~2,000 gas (just reads state)\n     */\n    function getEncryptedCounter() external view returns (euint32) {\n        return encryptedCounter;\n    }\n\n    /**\n     * @notice Decode and return counter value for authorized user\n     * @param signature User's decryption authorization signature\n     * @return Decrypted counter value (uint32)\n     * @dev Uses FHE.allow() to permit user decryption\n     * \n     * Advanced Pattern:\n     * 1. User signs authorization with their private key\n     * 2. Signature proves user owns the decryption capability\n     * 3. FHE.allow() grants decryption permission\n     * 4. Result returned as plaintext uint32\n     * \n     * Security:\n     * - Only authorized user can decrypt their own values\n     * - Signature prevents others from accessing data\n     */\n    function getCounterIfAuthorized(\n        bytes calldata signature\n    ) external view onlySignedPublicKey(signature) returns (uint32) {\n        // FHE.allow(encryptedCounter, msg.sender);\n        // return TFHE.decrypt(encryptedCounter);\n        // Note: Full implementation requires proper signature verification\n        // This is a skeleton demonstrating the pattern\n        return 0; // Placeholder\n    }\n\n    // ========================================================================\n    // ANTI-PATTERNS & DEMONSTRATIONS\n    // ========================================================================\n\n    /**\n     * @notice ❌ ANTI-PATTERN: Do NOT decrypt unnecessary values\n     * @dev This function demonstrates wasteful gas usage\n     * \n     * Problem:\n     * - Decryption costs significant gas (~200,000+)\n     * - Reveals encrypted data to contract\n     * - Defeats purpose of homomorphic encryption\n     * \n     * Fix:\n     * - Keep operations encrypted (use TFHE.add, TFHE.sub, etc.)\n     * - Only decrypt final results if necessary\n     * - Batch operations to minimize decryptions\n     */\n    function antiPattern_DecryptThenAdd(uint32 amount) external {\n        // ❌ WASTEFUL - DO NOT DO THIS\n        // uint32 decrypted = TFHE.decrypt(encryptedCounter);\n        // uint32 newValue = decrypted + amount;\n        // encryptedCounter = TFHE.asEuint32(newValue);\n        \n        // ✅ CORRECT - Keep encrypted\n        // encryptedCounter = TFHE.add(encryptedCounter, TFHE.asEuint32(amount));\n    }\n\n    /**\n     * @notice ❌ ANTI-PATTERN: Do NOT use encrypted values in loops\n     * @dev Gas cost becomes exponential\n     *\n     * Problem:\n     * for (uint i = 0; i < n; i++) {\n     *     encryptedCounter = TFHE.add(encryptedCounter, 1); // O(n) TFHE ops\n     * }\n     *\n     * Cost: ~45,000 * n gas (scales linearly with n)\n     *\n     * Fix:\n     * - Accumulate in a plaintext variable and encrypt once\n     * ```solidity\n     * uint32 sum = 0;\n     * for (uint i = 0; i < n; i++) {\n     *     sum += 1;\n     * }\n     * encryptedCounter = TFHE.add(encryptedCounter, TFHE.asEuint32(sum));\n     * ```\n     */\n\n    // ========================================================================\n    // GAS OPTIMIZATION NOTES\n    // ========================================================================\n\n    /**\n     * GAS OPTIMIZATION STRATEGIES:\n     * \n     * 1. STATE PACKING (Not applicable here - single euint32)\n     *    - euint types don't compress like uint8/uint16\n     *    - Store multiple euints if needed separately\n     * \n     * 2. OPERATION BATCHING\n     *    - Don't: incrementBy(1) called 10 times = 450,000 gas\n     *    - Do: incrementBy(10) once = 45,000 gas\n     *    - Batch operations to minimize TFHE ops\n     * \n     * 3. AVOID REDUNDANT OPERATIONS\n     *    - Each TFHE.add/sub costs ~45,000 gas\n     *    - Minimize number of homomorphic operations\n     *    - Cache results in plaintext when possible\n     * \n     * 4. EFFICIENT DECRYPTION\n     *    - Decryption is expensive (~200,000+ gas)\n     *    - Only decrypt final results, not intermediate values\n     *    - Never decrypt inside loops\n     * \n     * 5. ENCRYPTED STATE SIZE\n     *    - euint32: smaller than euint64 (slightly cheaper)\n     *    - Choose appropriate bit width for use case\n     * \n     * Estimated Gas Costs (fhEVM network):\n     * - TFHE.add(euint32, euint32): ~45,000\n     * - TFHE.sub(euint32, euint32): ~45,000\n     * - TFHE.asEuint32(uint32): ~5,000\n     * - State read: ~2,000\n     * - State write: ~20,000\n     */\n\n    // ========================================================================\n    // ADVANCED PATTERNS\n    // ========================================================================\n\n    /**\n     * @notice Safe increment with overflow check\n     * @dev Demonstrates pattern for preventing overflow\n     * \n     * Note: This is a SKELETON - full implementation would decrypt\n     * and check before incrementing, which is expensive.\n     * \n     * Better approach:\n     * - Document maximum expected value\n     * - Use uint32 bounds (0 to 4,294,967,295)\n     * - Trust contract logic to maintain bounds\n     */\n    function safeIncrement() external {\n        // In production with access to decryption:\n        // uint32 currentValue = TFHE.decrypt(encryptedCounter);\n        // require(currentValue < 4294967295, \"Overflow prevented\");\n        // encryptedCounter = TFHE.add(encryptedCounter, 1);\n        \n        encryptedCounter = TFHE.add(encryptedCounter, 1);\n    }\n\n    /**\n     * @notice Conditional increment based on encrypted comparison\n     * @param threshold Encrypted threshold value\n     * @dev Demonstrates homomorphic comparison returning ebool\n     * \n     * Advanced Pattern:\n     * 1. Compare encrypted values: TFHE.gt(counter, threshold) → ebool\n     * 2. Result remains encrypted as ebool\n     * 3. Use encrypted boolean in conditional logic\n     * 4. No decryption needed to evaluate condition\n     * \n     * Gas: ~50,000 gas (comparison + conditional add)\n     */\n    function conditionalIncrement(euint32 threshold) external {\n        // Get encrypted boolean: is counter > threshold?\n        ebool isGreater = TFHE.gt(encryptedCounter, threshold);\n        \n        // Conditional increment:\n        // If isGreater is true (encrypted), add 1\n        // If false, add 0 (no change)\n        // TFHE.select handles encrypted boolean\n        euint32 increment = TFHE.select(isGreater, TFHE.asEuint32(1), TFHE.asEuint32(0));\n        encryptedCounter = TFHE.add(encryptedCounter, increment);\n        \n        emit Incremented(msg.sender, block.timestamp);\n    }\n}\n"
      },
      "project/examples/blind-auction-premium/contracts/BlindAuctionPremium.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\n/**\n * BlindAuctionPremium.sol\n *\n * Purpose: Demonstrate a sealed-bid (blind) auction pattern with encrypted\n * bids stored on-chain. Bids remain encrypted (`euint32`) and the off-chain\n * gateway performs winner selection and provides an encrypted winning bid\n * along with the revealed winner address for on-chain settlement.\n *\n * Notes:\n * - This is an educational example. Real confidentiality requires careful\n *   gateway, replay protection, and signature validation.\n */\n\nimport { TFHE, euint32 } from \"fhevm/lib/TFHE.sol\";\n\ncontract BlindAuctionPremium {\n    address public owner;\n\n    enum Phase { Auction, Closed, Finalized }\n    Phase public phase;\n\n    // bidder -> encrypted bid\n    mapping(address => euint32) public encryptedBids;\n    address[] public bidders;\n\n    address public winner;\n    euint32 public winningBid; // encrypted winning bid (provided at finalize)\n\n    event BidSubmitted(address indexed bidder, euint32 encryptedBid);\n    event AuctionClosed();\n    event AuctionFinalized(address indexed winner, euint32 encryptedWinningBid);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"not-owner\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n        phase = Phase.Auction;\n    }\n\n    /// Submit an encrypted sealed bid during the Auction phase.\n    function submitBid(euint32 encryptedBid) external {\n        require(phase == Phase.Auction, \"not-auction-phase\");\n        require(TFHE.isZero(encryptedBids[msg.sender]) ? true : false, \"already-bid\");\n        encryptedBids[msg.sender] = encryptedBid;\n        bidders.push(msg.sender);\n        emit BidSubmitted(msg.sender, encryptedBid);\n    }\n\n    /// Close the bidding phase; off-chain gateway should compute the winner next.\n    function closeBidding() external onlyOwner {\n        require(phase == Phase.Auction, \"wrong-phase\");\n        phase = Phase.Closed;\n        emit AuctionClosed();\n    }\n\n    /// Finalize the auction by providing the winner address and encrypted winning bid.\n    /// In production this should be accompanied by cryptographic proof or gateway\n    /// signature verifying the selection.\n    function finalizeAuction(address _winner, euint32 _winningBid) external onlyOwner {\n        require(phase == Phase.Closed, \"wrong-phase\");\n        winner = _winner;\n        winningBid = _winningBid;\n        phase = Phase.Finalized;\n        emit AuctionFinalized(_winner, _winningBid);\n    }\n\n    /// Utility: return number of bidders\n    function bidderCount() external view returns (uint256) {\n        return bidders.length;\n    }\n}\n"
      },
      "project/examples/blind-dex-premium/contracts/BlindDEXPremium.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\n/*\n * BlindDEXPremium.sol\n *\n * Purpose: Demonstrate a privacy-preserving orderbook/DEX pattern where\n * orders are stored as encrypted primitives (`euint32`) and matching is\n * performed off-chain by a gateway which then provides encrypted settlement\n * details to finalize trades on-chain.\n *\n * This example is intentionally simple and educational — production-grade\n * orderbooks need careful anti-front-running, replay protection, and proofs.\n */\n\nimport { TFHE, euint32 } from \"fhevm/lib/TFHE.sol\";\n\ncontract BlindDEXPremium {\n    address public owner;\n\n    struct Order {\n        address maker;\n        euint32 encryptedAmount; // encrypted amount\n        euint32 encryptedPrice;  // encrypted price\n        bool exists;\n    }\n\n    uint256 public orderCount;\n    mapping(uint256 => Order) public orders;\n\n    event OrderPlaced(uint256 indexed id, address indexed maker, euint32 encryptedAmount, euint32 encryptedPrice);\n    event OrderCancelled(uint256 indexed id);\n    event TradeFinalized(uint256 indexed buyOrderId, uint256 indexed sellOrderId, euint32 encryptedAmount, euint32 encryptedPrice);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"not-owner\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    /// Place an encrypted order\n    function placeOrder(euint32 encryptedAmount, euint32 encryptedPrice) external returns (uint256) {\n        uint256 id = orderCount++;\n        orders[id] = Order({ maker: msg.sender, encryptedAmount: encryptedAmount, encryptedPrice: encryptedPrice, exists: true });\n        emit OrderPlaced(id, msg.sender, encryptedAmount, encryptedPrice);\n        return id;\n    }\n\n    /// Cancel an open order\n    function cancelOrder(uint256 id) external {\n        Order storage o = orders[id];\n        require(o.exists, \"no-order\");\n        require(o.maker == msg.sender, \"not-maker\");\n        delete orders[id];\n        emit OrderCancelled(id);\n    }\n\n    /// Finalize a trade: owner (gateway operator) provides matched order ids\n    /// and encrypted settlement details. In production, this should come with\n    /// a verifiable signature from the gateway.\n    function finalizeTrade(uint256 buyOrderId, uint256 sellOrderId, euint32 encryptedAmount, euint32 encryptedPrice) external onlyOwner {\n        require(orders[buyOrderId].exists, \"no-buy-order\");\n        require(orders[sellOrderId].exists, \"no-sell-order\");\n\n        // remove orders to mark them filled\n        delete orders[buyOrderId];\n        delete orders[sellOrderId];\n\n        emit TradeFinalized(buyOrderId, sellOrderId, encryptedAmount, encryptedPrice);\n    }\n}\n"
      },
      "project/examples/comparisons-premium/contracts/ComparisonsPremium.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"fhevm/abstracts/EIP712WithModifier.sol\";\nimport \"fhevm/abstracts/Reencrypt.sol\";\nimport \"fhevm/lib/TFHE.sol\";\n\n/**\n * @title ComparisonsPremium\n * @notice Premium comparison patterns for encrypted values (gt, lt, eq, select)\n *\n * @dev This contract demonstrates:\n * - Homomorphic comparisons producing `ebool`\n * - Using `TFHE.select` to branch without decryption\n * - Anti-patterns and gas notes\n */\ncontract ComparisonsPremium is EIP712WithModifier, Reencrypt {\n    euint32 private a;\n    euint32 private b;\n\n    address private owner;\n\n    event ASet(address indexed setter);\n    event BSet(address indexed setter);\n    event Compared(address indexed caller);\n\n    constructor() EIP712WithModifier(\"ComparisonsPremium\", \"1\") {\n        owner = msg.sender;\n        a = TFHE.asEuint32(0);\n        b = TFHE.asEuint32(0);\n    }\n\n    // ------------------ Setters ------------------\n    function setA(euint32 _a) external {\n        a = _a;\n        emit ASet(msg.sender);\n    }\n\n    function setB(euint32 _b) external {\n        b = _b;\n        emit BSet(msg.sender);\n    }\n\n    // ------------------ Comparisons ------------------\n\n    /**\n     * @notice Returns encrypted boolean if A > B\n     * @return ebool encrypted boolean\n     */\n    function isAGreaterThanB() external view returns (ebool) {\n        return TFHE.gt(a, b);\n    }\n\n    /**\n     * @notice Returns encrypted boolean if A < B\n     */\n    function isALessThanB() external view returns (ebool) {\n        return TFHE.lt(a, b);\n    }\n\n    /**\n     * @notice Returns encrypted boolean if A == B\n     */\n    function isAEqualB() external view returns (ebool) {\n        return TFHE.eq(a, b);\n    }\n\n    /**\n     * @notice Select between two encrypted values based on encrypted boolean\n     * @param threshold Encrypted threshold to compare with `a`\n     * @dev Demonstrates TFHE.select(trueVal, falseVal)\n     */\n    function selectBasedOnThreshold(euint32 threshold) external {\n        ebool cond = TFHE.gt(a, threshold);\n        // If cond => choose a + b, else choose a\n        euint32 choice1 = TFHE.add(a, b);\n        euint32 choice2 = a;\n        euint32 selected = TFHE.select(cond, choice1, choice2);\n        // store selected into a\n        a = selected;\n        emit Compared(msg.sender);\n    }\n\n    // ------------------ Anti-patterns ------------------\n    /**\n     * @notice ❌ ANTI-PATTERN: Decrypt for branching\n     * @dev Decrypting to perform if/else is expensive and leaks information\n     */\n    function antiPattern_decryptBranch() external {\n        // uint32 val = TFHE.decrypt(a);\n        // if (val > 10) { ... }\n        // Avoid this - use homomorphic comparisons\n    }\n\n    // ------------------ Utilities ------------------\n    function getA() external view returns (euint32) { return a; }\n    function getB() external view returns (euint32) { return b; }\n\n    function setOwner(address newOwner) external { require(msg.sender == owner, \"only-owner\"); owner = newOwner; }\n}\n"
      },
      "project/examples/confidential-stablecoin-premium/contracts/ConfidentialStablecoinPremium.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\n/*\n * ConfidentialStablecoinPremium.sol\n *\n * Purpose: Illustrate a privacy-preserving stablecoin pattern where balances\n * are encrypted (`euint32`). Minting and redemption are controlled, and\n * actual peg maintenance / off-chain settlement is handled by a gateway.\n *\n * Notes:\n * - Balances are encrypted and stored in `encryptedBalances`.\n * - `redeemEncrypted` marks a redemption request; actual settlement must be\n *   performed off-chain after decryption/verification.\n */\n\nimport { TFHE, euint32 } from \"fhevm/lib/TFHE.sol\";\n\ncontract ConfidentialStablecoinPremium {\n    address public owner;\n\n    mapping(address => euint32) private encryptedBalances;\n\n    event EncryptedMint(address indexed to, euint32 amount);\n    event EncryptedTransfer(address indexed from, address indexed to, euint32 amount);\n    event EncryptedRedeemRequested(address indexed from, euint32 amount, address indexed recipient);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"not-owner\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    /// Owner mints encrypted amount into `to`'s encrypted balance\n    function mintEncrypted(address to, euint32 amount) external onlyOwner {\n        encryptedBalances[to] = TFHE.add(encryptedBalances[to], amount);\n        emit EncryptedMint(to, amount);\n    }\n\n    /// Transfer encrypted amount between accounts (homomorphic ops)\n    function transferEncrypted(address to, euint32 amount) external {\n        address from = msg.sender;\n        encryptedBalances[from] = TFHE.sub(encryptedBalances[from], amount);\n        encryptedBalances[to] = TFHE.add(encryptedBalances[to], amount);\n        emit EncryptedTransfer(from, to, amount);\n    }\n\n    /// Request redemption: caller requests an off-chain settlement to `recipient`.\n    /// The contract records the request (encrypted amount) so an off-chain gateway\n    /// can perform decryption, verification, and payout.\n    function redeemEncrypted(euint32 amount, address recipient) external {\n        address from = msg.sender;\n        encryptedBalances[from] = TFHE.sub(encryptedBalances[from], amount);\n        emit EncryptedRedeemRequested(from, amount, recipient);\n    }\n\n    /// View encrypted balance\n    function encryptedBalanceOf(address who) external view returns (euint32) {\n        return encryptedBalances[who];\n    }\n}\n"
      },
      "project/examples/dao-voting-premium/contracts/DAOVotingPremium.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\n/*\n * DAOVotingPremium.sol\n *\n * Purpose: Demonstrate encrypted proposal creation and private voting\n * patterns. Votes are submitted as encrypted primitives (euint32). Tallying\n * and winner selection are performed off-chain by a gateway which then\n * finalizes the result on-chain by providing the encrypted tally and\n * declared winner address.\n */\n\nimport { TFHE, euint32 } from \"fhevm/lib/TFHE.sol\";\n\ncontract DAOVotingPremium {\n    address public owner;\n\n    enum Phase { Open, Closed, Finalized }\n\n    struct Proposal {\n        address proposer;\n        euint32 metadata; // encrypted proposal payload (e.g., description hash)\n        euint32 encryptedYesTally;\n        euint32 encryptedNoTally;\n        Phase phase;\n        address winner; // address chosen by gateway when finalizing\n        bool exists;\n    }\n\n    mapping(uint256 => Proposal) public proposals;\n    uint256 public proposalCount;\n\n    // track who voted for a proposal\n    mapping(uint256 => mapping(address => bool)) public hasVoted;\n\n    event ProposalCreated(uint256 indexed id, address indexed proposer);\n    event VoteCast(uint256 indexed id, address indexed voter, euint32 encryptedYes);\n    event VotingClosed(uint256 indexed id);\n    event VotingFinalized(uint256 indexed id, address indexed winner, euint32 encryptedYesTally);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"not-owner\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    /// Create a new proposal with encrypted metadata\n    function createProposal(euint32 metadata) external returns (uint256) {\n        uint256 id = proposalCount++;\n        proposals[id] = Proposal({\n            proposer: msg.sender,\n            metadata: metadata,\n            encryptedYesTally: TFHE.asEuint32(0),\n            encryptedNoTally: TFHE.asEuint32(0),\n            phase: Phase.Open,\n            winner: address(0),\n            exists: true\n        });\n        emit ProposalCreated(id, msg.sender);\n        return id;\n    }\n\n    /// Cast an encrypted vote: `encryptedYes` should be a ciphertext representing 1 for yes, 0 for no.\n    /// Voters must provide the encrypted bit-of-vote computed client-side and signed by the gateway.\n    function castVote(uint256 id, euint32 encryptedYes) external {\n        require(proposals[id].exists, \"no-proposal\");\n        require(proposals[id].phase == Phase.Open, \"not-open\");\n        require(!hasVoted[id][msg.sender], \"already-voted\");\n\n        // add the encryptedYes to the running yes tally; the caller is expected to\n        // submit either an encrypted 1 or 0. For accountability the gateway should\n        // validate signatures off-chain.\n        proposals[id].encryptedYesTally = TFHE.add(proposals[id].encryptedYesTally, encryptedYes);\n        // encryptedNoTally remains derivable off-chain (total - yes) if needed.\n\n        hasVoted[id][msg.sender] = true;\n        emit VoteCast(id, msg.sender, encryptedYes);\n    }\n\n    /// Close voting for a proposal (owner or governance module)\n    function closeVoting(uint256 id) external onlyOwner {\n        require(proposals[id].exists, \"no-proposal\");\n        require(proposals[id].phase == Phase.Open, \"wrong-phase\");\n        proposals[id].phase = Phase.Closed;\n        emit VotingClosed(id);\n    }\n\n    /// Finalize a proposal: the gateway/off-chain process provides the encrypted\n    /// yes tally and declares the winner address. This function records the\n    /// result on-chain; cryptographic proofs should accompany this in production.\n    function finalizeVoting(uint256 id, address chosenWinner, euint32 encryptedYesTally) external onlyOwner {\n        require(proposals[id].exists, \"no-proposal\");\n        require(proposals[id].phase == Phase.Closed, \"not-closed\");\n        proposals[id].phase = Phase.Finalized;\n        proposals[id].winner = chosenWinner;\n        proposals[id].encryptedYesTally = encryptedYesTally;\n        emit VotingFinalized(id, chosenWinner, encryptedYesTally);\n    }\n}\n"
      },
      "project/examples/encrypted-poker-premium/contracts/EncryptedPokerPremium.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\n/*\n * EncryptedPokerPremium.sol\n *\n * Purpose: Educational example showing encrypted hand submission and\n * gateway-finalized winner selection. Hands are stored as encrypted\n * primitives (`euint32`) and the gateway performs dealing, shuffling,\n * and winner determination off-chain.\n */\n\nimport { TFHE, euint32 } from \"fhevm/lib/TFHE.sol\";\n\ncontract EncryptedPokerPremium {\n    address public owner;\n\n    struct Game {\n        address[] players;\n        mapping(address => euint32) encryptedHands;\n        euint32 pot; // encrypted pot\n        bool started;\n        address winner;\n        euint32 winningHand; // encrypted winning hand\n        bool finalized;\n        bool exists;\n    }\n\n    uint256 public gameCount;\n    mapping(uint256 => Game) private games;\n\n    event GameCreated(uint256 indexed gameId, address indexed creator, address[] players);\n    event HandSubmitted(uint256 indexed gameId, address indexed player, euint32 encryptedHand);\n    event GameStarted(uint256 indexed gameId);\n    event GameFinalized(uint256 indexed gameId, address indexed winner, euint32 encryptedWinningHand, euint32 encryptedPot);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"not-owner\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    /// Create a game and register players\n    function createGame(address[] calldata players) external returns (uint256) {\n        uint256 id = gameCount++;\n        Game storage g = games[id];\n        for (uint256 i = 0; i < players.length; i++) {\n            g.players.push(players[i]);\n        }\n        g.exists = true;\n        emit GameCreated(id, msg.sender, players);\n        return id;\n    }\n\n    /// Players submit their encrypted hand (e.g., encoded cards ciphertext)\n    function submitHand(uint256 gameId, euint32 encryptedHand) external {\n        Game storage g = games[gameId];\n        require(g.exists, \"no-game\");\n        require(!g.started, \"already-started\");\n        // record encrypted hand\n        g.encryptedHands[msg.sender] = encryptedHand;\n        emit HandSubmitted(gameId, msg.sender, encryptedHand);\n    }\n\n    /// Start the game (no further hand submissions allowed)\n    function startGame(uint256 gameId, euint32 encryptedInitialPot) external onlyOwner {\n        Game storage g = games[gameId];\n        require(g.exists, \"no-game\");\n        g.started = true;\n        g.pot = TFHE.add(g.pot, encryptedInitialPot);\n        emit GameStarted(gameId);\n    }\n\n    /// Finalize the game: gateway/owner provides winner and encrypted winning hand and pot\n    function finalizeGame(uint256 gameId, address winningPlayer, euint32 encryptedWinningHand, euint32 encryptedPot) external onlyOwner {\n        Game storage g = games[gameId];\n        require(g.exists, \"no-game\");\n        require(g.started, \"not-started\");\n        require(!g.finalized, \"already-finalized\");\n        g.winner = winningPlayer;\n        g.winningHand = encryptedWinningHand;\n        g.pot = encryptedPot;\n        g.finalized = true;\n        emit GameFinalized(gameId, winningPlayer, encryptedWinningHand, encryptedPot);\n    }\n\n    /// View functions\n    function playersOf(uint256 gameId) external view returns (address[] memory) {\n        return games[gameId].players;\n    }\n\n    function encryptedHandOf(uint256 gameId, address player) external view returns (euint32) {\n        return games[gameId].encryptedHands[player];\n    }\n\n    function gameInfo(uint256 gameId) external view returns (address[] memory, euint32, bool, address, euint32, bool) {\n        Game storage g = games[gameId];\n        return (g.players, g.pot, g.started, g.winner, g.winningHand, g.finalized);\n    }\n}\n"
      },
      "project/examples/erc7984-premium/contracts/ERC7984Premium.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\n/*\n * ERC7984Premium.sol\n *\n * Purpose: Illustrate a modular private-token pattern (inspired by an\n * imaginary `ERC7984` privacy-focused extension). Balances and allowances\n * are kept encrypted (`euint32`). Modules can be registered to act as\n * minters. Approvals and transferFrom use encrypted allowances updated\n * homomorphically.\n */\n\nimport { TFHE, euint32 } from \"fhevm/lib/TFHE.sol\";\n\ncontract ERC7984Premium {\n    address public owner;\n\n    mapping(address => euint32) private encryptedBalances;\n    mapping(address => mapping(address => euint32)) private encryptedAllowances; // owner => spender => enc allowance\n    mapping(address => bool) public modules; // modules authorized to mint\n\n    event ModuleRegistered(address indexed module);\n    event EncryptedMintByModule(address indexed module, address indexed to, euint32 amount);\n    event EncryptedApproval(address indexed owner, address indexed spender, euint32 amount);\n    event EncryptedTransferFrom(address indexed spender, address indexed from, address indexed to, euint32 amount);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"not-owner\");\n        _;\n    }\n\n    modifier onlyModule() {\n        require(modules[msg.sender], \"not-module\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    /// Owner registers a module that can mint on behalf of users.\n    function registerModule(address module) external onlyOwner {\n        modules[module] = true;\n        emit ModuleRegistered(module);\n    }\n\n    /// Modules mint encrypted amounts to a recipient (homomorphic add)\n    function mintByModule(address to, euint32 amount) external onlyModule {\n        encryptedBalances[to] = TFHE.add(encryptedBalances[to], amount);\n        emit EncryptedMintByModule(msg.sender, to, amount);\n    }\n\n    /// User approves a spender with an encrypted allowance\n    function approveEncrypted(address spender, euint32 amount) external {\n        address ownerAddr = msg.sender;\n        encryptedAllowances[ownerAddr][spender] = amount;\n        emit EncryptedApproval(ownerAddr, spender, amount);\n    }\n\n    /// Spender transfers from owner to `to` using encrypted allowance subtraction\n    function transferFromEncrypted(address from, address to, euint32 amount) external {\n        address spender = msg.sender;\n        // subtract allowance homomorphically\n        encryptedAllowances[from][spender] = TFHE.sub(encryptedAllowances[from][spender], amount);\n        // subtract from sender balance, add to recipient\n        encryptedBalances[from] = TFHE.sub(encryptedBalances[from], amount);\n        encryptedBalances[to] = TFHE.add(encryptedBalances[to], amount);\n        emit EncryptedTransferFrom(spender, from, to, amount);\n    }\n\n    function encryptedBalanceOf(address who) external view returns (euint32) {\n        return encryptedBalances[who];\n    }\n\n    function encryptedAllowanceOf(address ownerAddr, address spender) external view returns (euint32) {\n        return encryptedAllowances[ownerAddr][spender];\n    }\n}\n"
      },
      "project/examples/handles-lifecycle-premium/contracts/HandlesLifecyclePremium.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\n/*\n * HandlesLifecyclePremium.sol\n *\n * Purpose: Demonstrate encrypted handle creation, persistence, expiry,\n * and safe lifecycle transitions. The contract stores handles (opaque ids)\n * mapped to encrypted metadata values. Expiry and transfers are controlled\n * on-chain while decryption of metadata remains off-chain.\n */\n\nimport { TFHE, euint32 } from \"fhevm/lib/TFHE.sol\";\n\ncontract HandlesLifecyclePremium {\n    struct Handle {\n        address owner;\n        euint32 metadata; // encrypted metadata (e.g., pointer, quota)\n        uint64 expiresAt; // unix timestamp; 0 means never\n        bool exists;\n    }\n\n    mapping(bytes32 => Handle) private handles;\n\n    event HandleCreated(bytes32 indexed handleId, address indexed owner, uint64 expiresAt);\n    event HandleTransferred(bytes32 indexed handleId, address indexed from, address indexed to);\n    event HandleExpired(bytes32 indexed handleId);\n\n    /// Create a handle with encrypted metadata and optional ttl (seconds)\n    function createHandle(euint32 metadata, uint64 ttlSeconds) external returns (bytes32) {\n        bytes32 handleId = keccak256(abi.encodePacked(msg.sender, metadata, block.timestamp));\n        require(!handles[handleId].exists, \"handle-exists\");\n\n        uint64 expiry = 0;\n        if (ttlSeconds > 0) {\n            expiry = uint64(block.timestamp) + ttlSeconds;\n        }\n\n        handles[handleId] = Handle({\n            owner: msg.sender,\n            metadata: metadata,\n            expiresAt: expiry,\n            exists: true\n        });\n\n        emit HandleCreated(handleId, msg.sender, expiry);\n        return handleId;\n    }\n\n    /// Transfer a handle to another owner (only current owner)\n    function transferHandle(bytes32 handleId, address to) external {\n        Handle storage h = handles[handleId];\n        require(h.exists, \"no-handle\");\n        require(h.owner == msg.sender, \"not-owner\");\n        require(!isExpired(handleId), \"expired\");\n\n        address from = h.owner;\n        h.owner = to;\n        emit HandleTransferred(handleId, from, to);\n    }\n\n    /// Expire a handle immediately (owner-only) — demonstrates lifecycle\n    function expireHandle(bytes32 handleId) external {\n        Handle storage h = handles[handleId];\n        require(h.exists, \"no-handle\");\n        require(h.owner == msg.sender, \"not-owner\");\n        h.expiresAt = uint64(block.timestamp);\n        emit HandleExpired(handleId);\n    }\n\n    /// Internal helper to check expiry\n    function isExpired(bytes32 handleId) public view returns (bool) {\n        Handle storage h = handles[handleId];\n        if (!h.exists) return true;\n        if (h.expiresAt == 0) return false;\n        return uint64(block.timestamp) >= h.expiresAt;\n    }\n\n    /// View owner (zero address if expired or non-existent)\n    function ownerOf(bytes32 handleId) external view returns (address) {\n        if (isExpired(handleId)) return address(0);\n        return handles[handleId].owner;\n    }\n\n    /// View encrypted metadata (callers may receive encrypted payload)\n    function metadataOf(bytes32 handleId) external view returns (euint32) {\n        require(!isExpired(handleId), \"expired\");\n        return handles[handleId].metadata;\n    }\n\n    /// Batch expire handles that are past their expiry timestamp (gas-bounded)\n    /// Caller should supply handles to check; this avoids an unbounded sweep.\n    function expireBatch(bytes32[] calldata ids) external {\n        for (uint256 i = 0; i < ids.length; i++) {\n            bytes32 id = ids[i];\n            if (handles[id].exists && handles[id].expiresAt != 0 && uint64(block.timestamp) >= handles[id].expiresAt) {\n                handles[id].expiresAt = uint64(block.timestamp);\n                emit HandleExpired(id);\n            }\n        }\n    }\n}\n"
      },
      "project/examples/input-proofs-premium/contracts/InputProofsPremium.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"fhevm/abstracts/EIP712WithModifier.sol\";\nimport \"fhevm/abstracts/Reencrypt.sol\";\nimport \"fhevm/lib/TFHE.sol\";\n\n/**\n * @title InputProofsPremium\n * @notice Demonstrates how to verify encrypted inputs meet constraints without revealing them.\n *\n * @dev Features:\n * - Homomorphic checks for range constraints (min <= value < max)\n * - Combination of boolean checks using TFHE.and / TFHE.or\n * - Example patterns for threshold checks and composite constraints\n * - Anti-patterns for inefficient verification (decrypt-first)\n * - Gas and security notes\n */\ncontract InputProofsPremium is EIP712WithModifier, Reencrypt {\n    constructor() EIP712WithModifier(\"InputProofsPremium\", \"1\") {}\n\n    mapping(address => euint32) public submitted;\n\n    event Submitted(address indexed who);\n    event Verified(address indexed who, bool success);\n\n    /**\n     * @notice Submit encrypted input for later verification\n     */\n    function submit(euint32 encValue) external {\n        submitted[msg.sender] = encValue;\n        emit Submitted(msg.sender);\n    }\n\n    /**\n     * @notice Verify a submitted value lies within [min, max)\n     * @param who Address of submitter\n     * @param encMin Encrypted minimum (inclusive)\n     * @param encMax Encrypted maximum (exclusive)\n     * @return ebool Encrypted boolean result of (min <= value && value < max)\n     *\n     * Pattern:\n     *  - TFHE.ge(value, min) -> ebool a\n     *  - TFHE.lt(value, max) -> ebool b\n     *  - TFHE.and(a, b) -> ebool result\n     */\n    function verifyRange(address who, euint32 encMin, euint32 encMax) external view returns (ebool) {\n        euint32 val = submitted[who];\n        ebool atLeast = TFHE.ge(val, encMin);\n        ebool lessThan = TFHE.lt(val, encMax);\n        ebool result = TFHE.and(atLeast, lessThan);\n        return result;\n    }\n\n    /**\n     * @notice Verify multiple constraints combined (example composite check)\n     * @dev Demonstrates combining more than two ebooleans safely\n     */\n    function verifyComposite(address who, euint32 encMin, euint32 encMax, euint32 encOtherThreshold) external view returns (ebool) {\n        euint32 val = submitted[who];\n        ebool inRange = TFHE.and(TFHE.ge(val, encMin), TFHE.lt(val, encMax));\n        ebool aboveOther = TFHE.gt(val, encOtherThreshold);\n        // final = inRange AND aboveOther\n        ebool finalRes = TFHE.and(inRange, aboveOther);\n        return finalRes;\n    }\n\n    /**\n     * @notice Anti-pattern: decrypt first and check on-chain\n     * @dev Decrypting exposes data and is expensive; avoid in production\n     */\n    function antiPattern_decryptAndCheck(address who, uint32 min, uint32 max) external pure {\n        // uint32 val = TFHE.decrypt(submitted[who]);\n        // require(val >= min && val < max, \"out-of-range\");\n        // Expensive and leaks data\n    }\n\n    /**\n     * @notice Helper: get submitted ciphertext for address\n     */\n    function getSubmitted(address who) external view returns (euint32) {\n        return submitted[who];\n    }\n}\n"
      },
      "project/examples/mev-arbitrage-premium/contracts/MEVArbitragePremium.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\n/*\n * MEVArbitragePremium.sol\n *\n * Purpose: Demonstrate a coordination pattern for private MEV/arbitrage\n * opportunities using encrypted price feeds. Price submissions and proposed\n * arbitrage actions are encrypted (`euint32`) and a trusted gateway/operator\n * finalizes profitable opportunities by providing encrypted settlement\n * details. This example focuses on data flow and privacy patterns, not\n * on the complexities of real MEV execution.\n */\n\nimport { TFHE, euint32 } from \"fhevm/lib/TFHE.sol\";\n\ncontract MEVArbitragePremium {\n    address public owner;\n\n    // symbol hash -> encrypted price\n    mapping(bytes32 => euint32) public encryptedPrice;\n\n    struct ArbitrageProposal {\n        address proposer;\n        bytes32 buySymbol;\n        bytes32 sellSymbol;\n        euint32 encryptedProfit; // encrypted expected profit\n        bool executed;\n        bool exists;\n    }\n\n    uint256 public proposalCount;\n    mapping(uint256 => ArbitrageProposal) public proposals;\n\n    event PriceSubmitted(bytes32 indexed symbol, euint32 encryptedPrice);\n    event ArbitrageProposed(uint256 indexed id, address indexed proposer, bytes32 buySymbol, bytes32 sellSymbol, euint32 encryptedProfit);\n    event ArbitrageFinalized(uint256 indexed id, address indexed executor, euint32 encryptedProfit);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"not-owner\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    /// Submit an encrypted price for a symbol (e.g., \"ETH/USDC\")\n    function submitEncryptedPrice(bytes32 symbol, euint32 price) external {\n        encryptedPrice[symbol] = price;\n        emit PriceSubmitted(symbol, price);\n    }\n\n    /// Propose an arbitrage opportunity between two symbols with expected encrypted profit\n    function proposeArbitrage(bytes32 buySymbol, bytes32 sellSymbol, euint32 encryptedProfit) external returns (uint256) {\n        uint256 id = proposalCount++;\n        proposals[id] = ArbitrageProposal({ proposer: msg.sender, buySymbol: buySymbol, sellSymbol: sellSymbol, encryptedProfit: encryptedProfit, executed: false, exists: true });\n        emit ArbitrageProposed(id, msg.sender, buySymbol, sellSymbol, encryptedProfit);\n        return id;\n    }\n\n    /// Owner/gateway finalizes an arbitrage: records execution and emits encrypted profit\n    function finalizeArbitrage(uint256 id, address executor, euint32 encryptedProfit) external onlyOwner {\n        require(proposals[id].exists, \"no-proposal\");\n        require(!proposals[id].executed, \"already-executed\");\n        proposals[id].executed = true;\n        emit ArbitrageFinalized(id, executor, encryptedProfit);\n    }\n\n    /// Helpers\n    function priceOf(bytes32 symbol) external view returns (euint32) {\n        return encryptedPrice[symbol];\n    }\n}\n"
      },
      "project/examples/private-erc20-premium/contracts/PrivateERC20Premium.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\n/*\n * PrivateERC20Premium.sol\n *\n * Purpose: Demonstrate a pattern for an ERC-20-like token that keeps\n * balances encrypted on-chain using fhEVM encrypted primitives. This is\n * a wrapper demonstration — it does not implement the standard ERC-20\n * plaintext interfaces because balances remain encrypted and private.\n *\n * Design notes:\n * - Balances are `euint32` encrypted primitives.\n * - Transfers operate on ciphertexts using homomorphic add/sub operations.\n * - Minting/burning must be owner-controlled (illustrative).\n * - Events emit only opaque encrypted primitives (avoid revealing plaintext).\n */\n\nimport { TFHE, euint32 } from \"fhevm/lib/TFHE.sol\";\n\ncontract PrivateERC20Premium {\n    address public owner;\n\n    // encrypted balances per address\n    mapping(address => euint32) private encryptedBalances;\n\n    event EncryptedMint(address indexed to, euint32 amount);\n    event EncryptedTransfer(address indexed from, address indexed to, euint32 amount);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"not-owner\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    /// @notice Owner-only: mint an encrypted amount into `to`'s encrypted balance.\n    function mintEncrypted(address to, euint32 amount) external onlyOwner {\n        encryptedBalances[to] = TFHE.add(encryptedBalances[to], amount);\n        emit EncryptedMint(to, amount);\n    }\n\n    /// @notice Transfer an encrypted amount from caller to `to`.\n    /// @dev This uses TFHE.sub to consume sender ciphertext and TFHE.add for recipient.\n    function transferEncrypted(address to, euint32 amount) external {\n        address from = msg.sender;\n        encryptedBalances[from] = TFHE.sub(encryptedBalances[from], amount);\n        encryptedBalances[to] = TFHE.add(encryptedBalances[to], amount);\n        emit EncryptedTransfer(from, to, amount);\n    }\n\n    /// @notice View the encrypted balance for `who`.\n    function encryptedBalanceOf(address who) external view returns (euint32) {\n        return encryptedBalances[who];\n    }\n\n    /// @notice (Anti-pattern) Reveal plaintext balance on-chain — intentionally omitted.\n    /// @dev Plaintext balance queries would defeat the privacy goal. Decrypt off-chain.\n}\n"
      },
      "project/examples/private-lending-premium/contracts/PrivateLendingPremium.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\n/*\n * PrivateLendingPremium.sol\n *\n * Purpose: Demonstrate confidential loan offers and encrypted collateral\n * accounting. Loan principals and collateral are stored as encrypted\n * primitives (`euint32`). Off-chain gateway is responsible for verification\n * of amounts, repayments, and solvency when necessary.\n */\n\nimport { TFHE, euint32 } from \"fhevm/lib/TFHE.sol\";\n\ncontract PrivateLendingPremium {\n    address public owner;\n\n    struct LoanOffer {\n        address lender;\n        address borrower;\n        euint32 principal;   // encrypted principal amount\n        euint32 collateral;  // encrypted collateral amount\n        uint64 duration;     // seconds\n        uint64 startAt;      // start timestamp when accepted\n        bool active;\n        bool repaid;\n        bool exists;\n    }\n\n    uint256 public offerCount;\n    mapping(uint256 => LoanOffer) public offers;\n\n    event LoanOfferCreated(uint256 indexed id, address indexed lender);\n    event LoanAccepted(uint256 indexed id, address indexed borrower, uint64 startAt);\n    event LoanRepaid(uint256 indexed id, address indexed borrower);\n    event LoanLiquidated(uint256 indexed id, address indexed lender);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"not-owner\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    /// Create a loan offer (lender-side) with encrypted principal and collateral\n    function createOffer(euint32 principal, euint32 collateral, uint64 duration) external returns (uint256) {\n        require(duration > 0, \"invalid-duration\");\n        uint256 id = offerCount++;\n        offers[id] = LoanOffer({\n            lender: msg.sender,\n            borrower: address(0),\n            principal: principal,\n            collateral: collateral,\n            duration: duration,\n            startAt: 0,\n            active: false,\n            repaid: false,\n            exists: true\n        });\n        emit LoanOfferCreated(id, msg.sender);\n        return id;\n    }\n\n    /// Borrower accepts the offer; contract records borrower and start time.\n    function acceptOffer(uint256 id) external {\n        LoanOffer storage o = offers[id];\n        require(o.exists, \"no-offer\");\n        require(o.borrower == address(0), \"already-accepted\");\n        o.borrower = msg.sender;\n        o.startAt = uint64(block.timestamp);\n        o.active = true;\n        emit LoanAccepted(id, msg.sender, o.startAt);\n    }\n\n    /// Borrower repays the loan (off-chain verification recommended)\n    function repayLoan(uint256 id, euint32 repayEncrypted) external {\n        LoanOffer storage o = offers[id];\n        require(o.exists, \"no-offer\");\n        require(o.active, \"not-active\");\n        require(o.borrower == msg.sender, \"not-borrower\");\n        // In production, gateway verifies repayment covers principal+interest.\n        o.repaid = true;\n        o.active = false;\n        emit LoanRepaid(id, msg.sender);\n    }\n\n    /// Lender can liquidate if duration passed and loan not repaid.\n    function liquidate(uint256 id) external {\n        LoanOffer storage o = offers[id];\n        require(o.exists, \"no-offer\");\n        require(o.lender == msg.sender, \"not-lender\");\n        require(o.active, \"not-active\");\n        require(uint64(block.timestamp) >= o.startAt + o.duration, \"not-matured\");\n        // Off-chain gateway would provide evidence; here we just mark liquidation.\n        o.active = false;\n        emit LoanLiquidated(id, msg.sender);\n    }\n\n    /// Helper to inspect an offer (amounts remain encrypted)\n    function offerInfo(uint256 id) external view returns (address, address, euint32, euint32, uint64, uint64, bool, bool) {\n        LoanOffer storage o = offers[id];\n        return (o.lender, o.borrower, o.principal, o.collateral, o.duration, o.startAt, o.active, o.repaid);\n    }\n}\n"
      },
      "project/examples/private-yield-premium/contracts/PrivateYieldPremium.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\n/*\n * PrivateYieldPremium.sol\n *\n * Purpose: Demonstrate encrypted staking and yield accrual accounting.\n * Staked amounts and accrued rewards are stored as encrypted primitives\n * (`euint32`). Off-chain gateway computes yield and provides encrypted\n * reward deltas which the contract records and allows claim by staker.\n */\n\nimport { TFHE, euint32 } from \"fhevm/lib/TFHE.sol\";\n\ncontract PrivateYieldPremium {\n    address public owner;\n\n    mapping(address => euint32) private encryptedStakes;\n    mapping(address => euint32) private encryptedRewards;\n\n    event Staked(address indexed staker, euint32 encryptedAmount);\n    event Withdrawn(address indexed staker, euint32 encryptedAmount);\n    event RewardAccrued(address indexed staker, euint32 encryptedReward);\n    event RewardClaimed(address indexed staker, euint32 encryptedReward);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"not-owner\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    /// Stake an encrypted amount (client provides ciphertext representing amount)\n    function stakeEncrypted(euint32 encryptedAmount) external {\n        encryptedStakes[msg.sender] = TFHE.add(encryptedStakes[msg.sender], encryptedAmount);\n        emit Staked(msg.sender, encryptedAmount);\n    }\n\n    /// Withdraw an encrypted amount; contract records the change but actual\n    /// transfer of plaintext value should be coordinated off-chain.\n    function withdrawEncrypted(euint32 encryptedAmount) external {\n        encryptedStakes[msg.sender] = TFHE.sub(encryptedStakes[msg.sender], encryptedAmount);\n        emit Withdrawn(msg.sender, encryptedAmount);\n    }\n\n    /// Owner/gateway accrues encrypted reward to a staker\n    function accrueReward(address staker, euint32 encryptedReward) external onlyOwner {\n        encryptedRewards[staker] = TFHE.add(encryptedRewards[staker], encryptedReward);\n        emit RewardAccrued(staker, encryptedReward);\n    }\n\n    /// Staker claims their encrypted rewards (recorded on-chain; off-chain\n    /// gateway handles decryption and payout)\n    function claimReward() external {\n        euint32 reward = encryptedRewards[msg.sender];\n        require(!TFHE.isZero(reward), \"no-rewards\");\n        encryptedRewards[msg.sender] = TFHE.asEuint32(0);\n        emit RewardClaimed(msg.sender, reward);\n    }\n\n    /// View encrypted balances and rewards\n    function encryptedStakeOf(address who) external view returns (euint32) {\n        return encryptedStakes[who];\n    }\n\n    function encryptedRewardsOf(address who) external view returns (euint32) {\n        return encryptedRewards[who];\n    }\n}\n"
      },
      "project/examples/public-encryption-premium/contracts/PublicEncryptionPremium.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"fhevm/abstracts/EIP712WithModifier.sol\";\nimport \"fhevm/abstracts/Reencrypt.sol\";\nimport \"fhevm/lib/TFHE.sol\";\n\n/**\n * @title PublicEncryptionPremium\n * @notice Demonstrates contract-level encryption and controlled public decryption patterns.\n *\n * @dev Patterns included:\n * - Store encrypted values on-chain\n * - Public decryption flow for transparent outputs (use sparingly)\n * - Re-encryption / allowTransient patterns for temporary access\n * - Gas and security notes\n *\n * Security: Public decryption reveals plaintext; use only when required by protocol.\n */\ncontract PublicEncryptionPremium is EIP712WithModifier, Reencrypt {\n    mapping(uint256 => euint32) private storageMap;\n    uint256 private counter;\n    address private owner;\n\n    event Stored(uint256 indexed id, address indexed who);\n    event PubliclyDecrypted(uint256 indexed id, address indexed who);\n    event ReencryptionAllowed(uint256 indexed id, address indexed who);\n\n    constructor() EIP712WithModifier(\"PublicEncryptionPremium\", \"1\") {\n        owner = msg.sender;\n        counter = 0;\n    }\n\n    /**\n     * @notice Store encrypted value on-chain and returns id\n     * @param value Encrypted value\n     * @return id Identifier for stored ciphertext\n     */\n    function storeEncrypted(euint32 value) external returns (uint256 id) {\n        id = ++counter;\n        storageMap[id] = value;\n        emit Stored(id, msg.sender);\n        return id;\n    }\n\n    /**\n     * @notice Publicly decrypt and return a value (for transparency)\n     * @dev WARNING: This reveals plaintext to everyone. Use for public outputs only.\n     * In this example we simulate public decryption by returning a placeholder uint32.\n     * Real-world decryption would require gateway involvement and signing.\n     */\n    function publicDecrypt(uint256 id) external returns (uint32) {\n        // Placeholder implementation: in real fhEVM, public decryption is handled by the gateway\n        // and the contract would use FHE.allow or similar to signal intent.\n        // Here we emit an event and return 0 as a stub.\n        require(id > 0 && id <= counter, \"invalid-id\");\n        emit PubliclyDecrypted(id, msg.sender);\n        return 0; // Placeholder - do not implement real decryption on-chain\n    }\n\n    /**\n     * @notice Allow transient re-encryption for an address (owner only)\n     * @dev Demonstrates pattern: grant short-lived permission to decrypt\n     */\n    function allowReencryption(uint256 id, address grantee) external {\n        require(msg.sender == owner, \"only-owner\");\n        require(id > 0 && id <= counter, \"invalid-id\");\n        // In an actual fhEVM integration: FHE.allowTransient(storageMap[id], grantee);\n        emit ReencryptionAllowed(id, grantee);\n    }\n\n    function getStored(uint256 id) external view returns (euint32) {\n        require(id > 0 && id <= counter, \"invalid-id\");\n        return storageMap[id];\n    }\n\n    function setOwner(address newOwner) external { require(msg.sender == owner, \"only-owner\"); owner = newOwner; }\n}\n"
      },
      "project/examples/single-encryption-premium/contracts/SingleEncryptionPremium.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"fhevm/abstracts/EIP712WithModifier.sol\";\nimport \"fhevm/abstracts/Reencrypt.sol\";\nimport \"fhevm/lib/TFHE.sol\";\n\n/**\n * @title SingleEncryptionPremium\n * @notice Demonstrates user-side encryption submission patterns and aggregated operations\n *\n * @dev Features:\n * - Users submit ciphertexts to the contract via `submitEncrypted`\n * - Contract stores per-user encrypted values\n * - Aggregation function `aggregate` homomorphically sums values for a set of addresses\n * - Limits to protect against expensive loops (`MAX_AGGREGATE = 20`)\n * - Anti-patterns and gas/security notes included\n */\ncontract SingleEncryptionPremium is EIP712WithModifier, Reencrypt {\n    mapping(address => euint32) private encryptedValues;\n    address[] private submitters;\n    mapping(address => bool) private hasSubmitted;\n\n    uint8 public constant MAX_AGGREGATE = 20;\n    address private owner;\n\n    event Submitted(address indexed submitter);\n    event Aggregated(address indexed caller, uint256 count);\n    event Cleared(address indexed caller);\n\n    constructor() EIP712WithModifier(\"SingleEncryptionPremium\", \"1\") {\n        owner = msg.sender;\n    }\n\n    /**\n     * @notice Submit an encrypted value (client encrypts value before sending)\n     * @param value Encrypted value (euint32)\n     * @dev If caller already submitted, this overwrites previous submission\n     */\n    function submitEncrypted(euint32 value) external {\n        if (!hasSubmitted[msg.sender]) {\n            submitters.push(msg.sender);\n            hasSubmitted[msg.sender] = true;\n        }\n        encryptedValues[msg.sender] = value;\n        emit Submitted(msg.sender);\n    }\n\n    /**\n     * @notice Aggregate encrypted values for provided addresses\n     * @param addrs Array of addresses to include in aggregation\n     * @return sum Encrypted sum (euint32)\n     * @dev Returns TFHE.add(... aggregated) for provided addresses\n     * - Reverts if `addrs.length > MAX_AGGREGATE` to protect gas\n     * - Empty list returns encrypted zero\n     */\n    function aggregate(address[] calldata addrs) public view returns (euint32 sum) {\n        require(addrs.length <= MAX_AGGREGATE, \"too-many-addrs\");\n        sum = TFHE.asEuint32(0);\n        for (uint i = 0; i < addrs.length; i++) {\n            address a = addrs[i];\n            if (hasSubmitted[a]) {\n                sum = TFHE.add(sum, encryptedValues[a]);\n            }\n        }\n        // Note: view function - does not modify state\n        return sum;\n    }\n\n    /**\n     * @notice Convenience: aggregate all current submitters (bounded by MAX_AGGREGATE)\n     */\n    function aggregateAll() external view returns (euint32 sum) {\n        require(submitters.length <= MAX_AGGREGATE, \"submitters-too-many\");\n        euint32 result = TFHE.asEuint32(0);\n        for (uint i = 0; i < submitters.length; i++) {\n            address a = submitters[i];\n            if (hasSubmitted[a]) {\n                result = TFHE.add(result, encryptedValues[a]);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @notice Clear stored submissions (owner only)\n     */\n    function clearSubmissions() external {\n        require(msg.sender == owner, \"only-owner\");\n        for (uint i = 0; i < submitters.length; i++) {\n            encryptedValues[submitters[i]] = TFHE.asEuint32(0);\n            hasSubmitted[submitters[i]] = false;\n        }\n        delete submitters;\n        emit Cleared(msg.sender);\n    }\n\n    // ---------------- Anti-patterns & Notes ----------------\n    /**\n     * @notice ❌ ANTI-PATTERN: Aggregating thousands of addresses on-chain\n     * @dev Avoid loops over unbounded arrays. Limit batch sizes and perform off-chain aggregation when possible.\n     */\n    function antiPattern_unboundedAggregation(address[] calldata arr) external pure {\n        // DO NOT use in production\n        // For demonstration only\n        if (arr.length > 1000) { revert(); }\n    }\n\n    function getSubmittersCount() external view returns (uint256) {\n        return submitters.length;\n    }\n\n    function getEncryptedFor(address who) external view returns (euint32) {\n        return encryptedValues[who];\n    }\n\n    function setOwner(address newOwner) external { require(msg.sender == owner, \"only-owner\"); owner = newOwner; }\n}\n"
      },
      "project/examples/swaps-premium/contracts/SwapsPremium.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\n/*\n * SwapsPremium.sol\n *\n * Purpose: Simple AMM/Swap example using encrypted reserves (euint32).\n * This contract demonstrates how homomorphic ops can model reserve\n * arithmetic without revealing plaintext reserves. It's an educational\n * example — production AMMs require careful design and off-chain tooling.\n */\n\nimport { TFHE, euint32 } from \"fhevm/lib/TFHE.sol\";\n\ncontract SwapsPremium {\n    // encrypted reserves for tokenA and tokenB\n    euint32 public reserveA;\n    euint32 public reserveB;\n\n    event LiquidityAdded(address indexed provider, euint32 amountA, euint32 amountB);\n    event Swap(address indexed trader, euint32 amountIn, euint32 amountOut);\n\n    /// @notice Add encrypted liquidity to the pool (homomorphic add)\n    function addLiquidity(euint32 amountA, euint32 amountB) external {\n        reserveA = TFHE.add(reserveA, amountA);\n        reserveB = TFHE.add(reserveB, amountB);\n        emit LiquidityAdded(msg.sender, amountA, amountB);\n    }\n\n    /// @notice Simple constant-product swap approximation using encrypted values.\n    /// @dev Because we can't compute division on-chain in ciphertext space here,\n    ///      this function models a naive flow: subtract input from reserveA,\n    ///      and return an encrypted output placeholder computed via TFHE.sub on reserveB.\n    ///      Real swap math must be performed in the gateway or using FHE-capable ops.\n    function swapAToB(euint32 amountIn) external returns (euint32) {\n        // naive: reserveA' = reserveA + amountIn\n        reserveA = TFHE.add(reserveA, amountIn);\n\n        // placeholder: compute amountOut as a homomorphic subtraction of a constant\n        // In practice, amountOut is computed off-chain and validated via a proof.\n        euint32 amountOut = TFHE.sub(reserveB, amountIn);\n        reserveB = TFHE.sub(reserveB, amountOut);\n\n        emit Swap(msg.sender, amountIn, amountOut);\n        return amountOut;\n    }\n\n    /// @notice View encrypted reserves\n    function getReserves() external view returns (euint32, euint32) {\n        return (reserveA, reserveB);\n    }\n}\n"
      },
      "project/examples/vesting-premium/contracts/VestingPremium.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\n/*\n * VestingPremium.sol\n *\n * Purpose: Demonstrate encrypted vesting schedules where amounts remain\n * encrypted on-chain. The contract records vest entries mapping to an\n * encrypted amount and a release timestamp. Claim releases are recorded\n * on-chain while decryption is performed off-chain by the gateway.\n */\n\nimport { TFHE, euint32 } from \"fhevm/lib/TFHE.sol\";\n\ncontract VestingPremium {\n    struct Vest {\n        address beneficiary;\n        euint32 amount; // encrypted vested amount\n        uint64 releaseAt; // unix timestamp\n        bool claimed;\n    }\n\n    uint256 public vestCount;\n    mapping(uint256 => Vest) public vests;\n\n    event VestCreated(uint256 indexed id, address indexed beneficiary, uint64 releaseAt);\n    event VestClaimed(uint256 indexed id, address indexed beneficiary);\n\n    /// Create a vesting entry with encrypted amount and release time\n    function createVest(address beneficiary, euint32 amount, uint64 releaseAt) external returns (uint256) {\n        require(beneficiary != address(0), \"zero-beneficiary\");\n        require(releaseAt > block.timestamp, \"release-in-past\");\n\n        uint256 id = vestCount++;\n        vests[id] = Vest({\n            beneficiary: beneficiary,\n            amount: amount,\n            releaseAt: releaseAt,\n            claimed: false\n        });\n\n        emit VestCreated(id, beneficiary, releaseAt);\n        return id;\n    }\n\n    /// Claim a vesting entry once release time passed.\n    /// This marks the vest as claimed. Actual transfer of plaintext tokens\n    /// must be performed off-chain by the holder/gateway after decryption.\n    function claimVest(uint256 id) external {\n        Vest storage v = vests[id];\n        require(!v.claimed, \"already-claimed\");\n        require(block.timestamp >= v.releaseAt, \"not-released\");\n        require(v.beneficiary == msg.sender, \"not-beneficiary\");\n\n        v.claimed = true;\n        emit VestClaimed(id, msg.sender);\n    }\n\n    /// View vest info (amount remains encrypted)\n    function vestInfo(uint256 id) external view returns (address, euint32, uint64, bool) {\n        Vest storage v = vests[id];\n        return (v.beneficiary, v.amount, v.releaseAt, v.claimed);\n    }\n}\n"
      }
    }
  }
}